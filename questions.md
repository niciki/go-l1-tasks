# 1. Какой самый эффективный способ конкатенации строк?
При сложении строк с помощью оператора `+` каждый раз создается в памяти создаётся новая строка. 
Это происходит ввиду неизменяемости строк в Go: при любом изменении создаётся новая строка.
Чтобы избавиться от лишних аллокаций, мы можем воспользоваться типом `strings.Builder` и методом `WriteString`. 
Именно этот метод является наиболее эфективным способом конкатенации двух строк.
```go
 func join(strs ...string) string {
    var sb strings.Builder
    for _, str := range strs {
            sb.WriteString(str)
    }
    return sb.String()
 }
 ```
 # 2. Что такое интерфейсы, как они применяются в Go?
Интерфейсный тип в Go — это своего рода определение. Он определяет и описывает конкретные методы, которые должны быть у какого-то другого типа.<br/>
Применение:
- Интерфейсы помогают уменьшить дублирование, то есть количество шаблонного кода.<br/>
    Например, можно написать функцию, которая будет принимать интерфейсный тип вместо написания кучи функций для каждой струтктуры, реализующей интерфейс.
- Они облегчают использование в модульных тестах заглушек вместо реальных объектов.
# 3. Чем отличаются RWMutex от Mutex?
`RWMutex` нужен, когда у нас есть объект, который нельзя параллельно писать, но можно параллельно читать. Например, стандартный тип `map`.
Перед записью в защищаемый мьютексом объект делается `.Lock()`, а вызовы `.Lock()` и `.RLock()` в других горутинах будут ждать, 
пока вы не отпустите мьютекс через `.Unlock()`.
Перед чтением защищаемого объекта делается `.RLock()` и только вызовы `.Lock()` в других горутинах блокируются, 
вызовы `.RLock()` спокойно проходят. Когда отпускаете мьютекс через `.RUnlock()`, 
ждущие вызовы `.Lock()` по-очереди могут забирать мьютекс на себя.
Таких образом обеспечивается параллельное чтение объекта несколькими горутинами, что улучшает производительность.
# 4. Чем отличаются буферизированные и не буферизированные каналы?
При создании канала мы можем указать/ не указать третий аргумент - размер буфера канала
```go
// небуферизованный канал целых чисел
ci := make(chan int)

// небуферизованный канал целых чисел            
cj := make(chan int, 0)   
     
// буферизованный канал целых чисел 
cs := make(chan int, 100)  
```
Приемники всегда блокируются, пока нет данных для приема. Если канал не буферизован, отправитель блокируется, 
пока получатель не получил значение. Если у канала есть буфер, отправитель блокируется только до того, как значение будет скопировано в буфер; 
если буфер заполнен, это означает ожидание, пока какой-либо получатель не получит значение.
# 5. Какой размер у структуры struct{}{}?
0 байт
# 6. Есть ли в Go перегрузка методов или операторов?
 В Go нет перегрузки методов и операторов.
# 7. В какой последовательности будут выведены элементы map[int]int?
Map в Go unordered, то есть не упорядоченная(hash map). Поэтому порядок обхода map будет не по порядку.
# 8. В чем разница make и new?
- Метод `make ()` выделяет место в памяти только для типов `slice`, `map` и `chan` и инициализирует объект. 
Его первый параметр - это тип, а второй параметр - параметр переменной длины, который возвращает сам тип. <br/>
Сигнатура: `func make(t Type, size ...IntegerType) Type`
1. Для типа **среза (среза)** первый размер представляет длину среза, а второй размер представляет собой емкость среза. Если указан только один
2.  параметр размера, емкость среза равна его длине;
3. Для типа **карты (словаря)** существует только один размер, который указывает, сколько места выделено для карты. Если этот параметр опущен, 
4. автоматически выделяется небольшое пространство (этот параметр обычно не требуется, поскольку карта автоматически расширяется);
5. Для типа **chan (pipe)** существует только один размер, который представляет буфер канала, и отсутствие параметра означает отсутствие буфера.
- Метод new () выделяет место в памяти. Его первым параметром является тип, а затем он возвращает указатель на область памяти этого типа.
Сигнатура: `func new(Type) *Type`
# 9. Сколько существует способов задать переменную типа slice или map?
- С помощью функции `make`, например ```arr := make(map[int]int)```
- С помощью инициализации, наприvер ```arr := map[int]int{1: 2, 2: 3}``` или ```var arr = map[int]int{1: 2, 2: 3}```
- С помощью опеределения переменной, например ```var arr map[int]int```. **НО!** Этот способ почти неприменим на практике, так как типы map
являются ссылочными типами, такими как указатели или срезы (slice), и поэтому значение равно nil;
оно не указывает на инициализированную карту. Нулевая карта (nil map) ведет себя как пустая карта при чтении,
но попытки записи в нулевую карту вызовут панику во время выполнения (runtime panic). 
# 10. Что выведет данная программа и почему?

```go
func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}

```
Данная программа выведет 1. Поскольку в функции записывается в копию переменной p, то в главной функции main в переменной p
никаких переменных не произойдет.
Для изменения переменной надо передать двойной указатель.
# 11. Что выведет данная программа и почему?
```go
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
```
Ввыод: `fatal error: all goroutines are asleep - deadlock!` так как в горутины `WaitGroup` передается не по указателю, а копией.
В `WaitGroup wg` не вызывается метод
`Done`. Поэтому в счетчике `wg` лежит значение 5. 
# 12. Что выведет данная программа и почему?
``` go
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
```
Ввыод: 0
В области видимости `if` создается новая переменная n, которая не влияет на переменную n, которая определена раньше. Поэтому после условия `if`
значение переменной n не поменялось и осталось равно 0.

# 13. Что выведет данная программа и почему?
```go
func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}
```
Вывод: [100 2 3 4 5] <br/>
Так как слайс - указатель на массив элементов, то в функции успешно был бы заменен первый элемент на 100. Далее, функция append возвращает слайс
с указателем на новый массив, и этот слайс записывается в копию переменной `v`. 
# 14. Что выведет данная программа и почему?
```go
func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}

```
Вывод: [b b a][a a]
В анонимной функции сначала выполняется функция `append` результат которой - слайс с указателем на массив с новой областью памяти.
Поэтому все, что выполняется далее, а именно замены 0 го и 1 го элемента не повлияют на переданный слайс.

